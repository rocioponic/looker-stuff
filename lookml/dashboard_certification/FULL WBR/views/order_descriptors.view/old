view: order_descriptors {
  sql_table_name: delta.central_order_descriptors_odp.order_descriptors_v2 ;;
  suggestions: no

  dimension: pk1_order_id {
    description: "Primary key"
    primary_key: yes
    hidden: yes
    type: number
    sql: ${TABLE}.order_id ;;
  }

  dimension: order_id {
    description: "Order ID"
    type: number
    sql: ${TABLE}.order_id ;;
  }

  dimension: courier_id {
    description: "Unique identifier for the courier associated with an order"
    type: number
    sql: ${TABLE}.courier_id ;;
  }

  dimension: customer_id {
    description: "Unique identifier for the customer associated with an order."
    type: number
    sql: ${TABLE}.customer_id ;;
  }

  dimension: order_cancel_reason {
    description: "Reason for the order's cancellation."
    type: string
    sql: ${TABLE}.order_cancel_reason ;;
  }

  dimension: order_cancel_comments {
    description: "Cancellation comment."
    type: string
    sql: ${TABLE}.order_cancel_comments ;;
  }

  dimension: order_code {
    description: "Alphanumeric code for an order (The one displayed in the app). Not unique."
    type: string
    sql: ${TABLE}.order_code ;;
  }

  dimension: order_courier_payment_method {
    description: "Payment method used for the courier. Contains nulls"
    type: string
    sql: ${TABLE}.order_courier_payment_method ;;
  }

  dimension: order_courier_provider {
    description: "Standard/Glovocares/3PL company"
    type: string
    sql: ${TABLE}.order_courier_provider ;;
  }

  #Time Granularity
  parameter: date_granularity {
    description: "Parameter to set granularity of creation time."
    label: "Time Granularity"
    type: unquoted

    allowed_value: { value: "day" }
    allowed_value: { value: "week" }
    allowed_value: { value: "month" }
    allowed_value: { value: "year" }
  }

  dimension: order_created_dynamic {
    description: "Dynamic creation time of an aggregate (date, week or month)"
    label: "Order Created Dynamic"
    # LAMS
    # rule_exemptions: {
    # F1: "2022-11-07 - Field does not reference another view but the value of a parameter of the view"
    # }
    sql:
      {% if date_granularity._parameter_value == 'week' %}
        ${p_creation_week}
      {% elsif date_granularity._parameter_value == 'month' %}
        ${p_creation_month}
      {% elsif date_granularity._parameter_value == 'year' %}
        ${p_creation_year}
      {% else %}
        ${p_creation_date}
      {% endif %} ;;
  }

  dimension: order_created_period_dynamic {
    description: "Dynamic creation time for periods (day, week, month, year) comparisons - yes when order
      was created in the last 2 <period>, where <period> adjusts to time granularity"
    label: "Order Created Period Dynamic"
    type: yesno
    hidden: yes
    # LAMS
    # rule_exemptions: {
    # F1: "2022-11-07 - Field does not reference another view but the value of a parameter of the view"
    # }
    sql:
      {% if date_granularity._parameter_value == 'week' %}
      -- If granularity is weeks, check if order_created_raw was in the last 2 weeks (current not included)
        ${order_created_raw} >=
        DATE_ADD('week', -2,
          DATE_TRUNC('DAY',
            DATE_ADD('day', (0 - MOD((DAY_OF_WEEK(current_date) % 7) - 1 + 7, 7)), current_date)
          )
        )
        AND ${order_created_raw} <
        DATE_TRUNC('DAY',
          DATE_ADD('day', (0 - MOD((DAY_OF_WEEK(current_date) % 7) - 1 + 7, 7)),current_date)
        )
      {% elsif date_granularity._parameter_value == 'month' %}
      -- If granularity is months, check if order_created_raw was in the last 2 months (current not included)
        ${order_created_raw} >= DATE_ADD('month', -2, DATE_TRUNC('MONTH', current_date))
        AND ${order_created_raw} < DATE_TRUNC( 'MONTH', current_date)
      {% elsif date_granularity._parameter_value == 'year' %}
      -- If granularity is years, check if order_created_raw was in the last 2 years (current not included)
        ${order_created_raw} >= DATE_ADD('year', -2, DATE_TRUNC('YEAR', current_date))
        AND ${order_created_raw} < DATE_TRUNC('YEAR', current_date)
      {% else %}
      -- If granularity is days, check if order_created_raw was in the last 2 days (today not included)
        ${order_created_raw} >= DATE_ADD('day', -2, current_date)
        AND ${order_created_raw} < current_date
      {% endif %} ;;
  }

  dimension: order_final_status {
    description: "Either DeliveredStatus or CanceledStatus. Whether the final status for the order
      is delivered or is canceled."
    type: string
    suggestions: ["DeliveredStatus", "CanceledStatus"]
    sql: ${TABLE}.order_final_status ;;
  }

  dimension: order_handling_strategy {
    description: "Possible values: GEN1, GEN2, IN_STORE or PICKUP. Tells us whether the order is delivered
      and is GEN1 (marketplace) or GEN2(delivered by Glovo) or the order was picked by the customer at the
      store (IN_STORE or PICKUP)"
    type: string
    sql: ${TABLE}.order_handling_strategy ;;
  }

  dimension: order_is_prime {
    description: "Flag indicating if an order is placed by an user with Glovo Prime."
    type: yesno
    sql: ${TABLE}.order_is_prime ;;
  }

  dimension: order_is_partner_order {
    description: "Flag indicating if an order is a Partner order. If the order was made to a Glovo partner
      the value will be TRUE, else FALSE, which means the partner is a fake account: we show the store and
      its menu in the app, but in reality it's like a QUIERO order because the store is not working with us,
      we make a courier go to the store and buy the products in the customer place."
    type: yesno
    sql: ${TABLE}.order_is_partner_order ;;
  }

  dimension: order_parent_id {
    description: "Unique identifier of the parent order, if any.
      'REMAKE', 'RESCUE' and 'SPLIT' are the possible values for the child order. A Remake/rescue/split
      order can also have child orders up to multiple times (E.g.: A remake order can have another
      child remake order). More details under ‘order_parent_relationship_type’ field below."
    type: number
    sql: ${TABLE}.order_parent_id ;;
  }

  dimension: order_parent_relationship_type {
    description: "Possible values: REMAKE, RESCUE, SPLIT, null.
      Orders can have child orders that operationally look the same as regular orders, but some of
      the fields are not correct. These child orders in Order Descriptors have already the sanitized
      fields from the parent order so no need to recompute anything.
      - REMAKE orders are orders created by liveops when some item is missing in the customer order.
      - RESCUE orders are also created by liveops. If for some reason the courier for the parent order
      cannot deliver the order, then liveops creates a rescue order and sends another courier to pick up
      the original order from the original courier, in order to finally deliver it.
      - SPLIT orders are created by backend or liveops whenever an order is too big for one courier to take,
      for example on QCommerce orders, if the user buys a lot of drinks."
    type: string
    sql: ${TABLE}.order_parent_relationship_type ;;
  }

  dimension: order_subvertical {
    description: "Subvertical for the vertical to be able to categorize the order even further. It can take
      values: eLogistics, On-Demand, Courier (Laas), Quiero, MFC, QCPartners (QCommerce) and
      Food - Food and Food - Other (Food)"
    type: string
    suggestions: [
      "Courier",
      "QCPartners",
      "Food - Food",
      "Food - Other",
      "Quiero",
      "MFC",
      "On-Demand"
    ]
    sql: ${TABLE}.order_subvertical ;;
  }

  dimension: order_subvertical2 {
    description: "Used to classify even further On-Demand subvertical in Food and Other and QCPartners
      in Retail and Groceries"
    type: string
    suggestions: [
      "Glovo On-Demand",
      "Food - Food",
      "Food - Other",
      "Glovo Business",
      "Quiero",
      "Groceries",
      "Courier",
      "Retail"
    ]
    sql: ${TABLE}.order_subvertical2 ;;
  }

  dimension: order_subvertical3 {
    description: "Used to classify even further Retail orders into Health and Shops"
    type: string
    suggestions: [
      "Courier",
      "Food - Food",
      "Food - Other",
      "Groceries",
      "Health",
      "On-Demand - Food",
      "On-Demand - Other",
      "Quiero",
      "Shops",
      "Smoking"
    ]
    sql: ${TABLE}.order_subvertical3 ;;
  }

  dimension: order_vertical {
    description: "Vertical to which the order was assigned to. There are 3 types of verticals: LaaS,
      Food and QCommerce. You can check how to calculate them in this
      miro: https://miro.com/app/board/uXjVOAERhUc=/ . More information on LaaS order definition
      here: https://glovoapp.atlassian.net/wiki/spaces/DATA/pages/3561127969/"
    type: string
    suggestions: [
      "Food",
      "LaaS",
      "QCommerce"
    ]
    sql: ${TABLE}.order_vertical ;;
  }

  dimension: store_address_id {
    description: "Unique identifier for the store address associated with an order.
      Takes into account if the order is remade/rescued."
    type: number
    sql: ${TABLE}.store_address_id ;;
  }

  dimension: store_id {
    description: "Unique identifier for the store associated with an order."
    type: number
    sql: ${TABLE}.store_id ;;
  }

  dimension: store_category_id {
    description: "Unique identifier for the store category from the store associated with the order."
    type: number
    sql: ${TABLE}.store_category_id ;;
  }

  dimension: order_total_purchase_eur {
    description: "Total price of the products bought for the order in major currency and euros. No
      fees are included here."
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_total_purchase_eur ;;
  }

  dimension: order_total_purchase_local {
    description: "Total price of the products bought for the order in major currency and local currency. No
      fees are included here."
    # LAMS
    # rule_exemptions: {
    # F1: "2022-12-19 - We need to reference this view to avoid more joins"
    # }
    type: number
    html: {{order_currency._value}} {{ rendered_value }};;
    sql: ${TABLE}.order_total_purchase_local ;;
  }

  dimension: order_total_effective_purchase_eur {
    description: "Total price of products payed by the customer, with discounts applied. Column in euros
      and major format."
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_total_effective_purchase_eur ;;
  }

  dimension: order_total_effective_purchase_local {
    description: "Total price of products payed by the customer, with discounts applied.
      Column in local currency and major format."
    # LAMS
    # rule_exemptions: {
    # F1: "2022-12-19 - We need to reference this view to avoid more joins"
    # }
    type: number
    html: {{order_currency._value}} {{ rendered_value }};;
    sql: ${TABLE}.order_total_effective_purchase_local ;;
  }

  dimension: order_delivery_fee_eur {
    description: "The delivery fee of the order in major currency and euros. This is the fee
      that the user pays associated with the store per the delivery"
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_delivery_fee_eur ;;
  }

  dimension: order_service_fee_eur {
    description: "An extra charge assessed for the service in euros and major currency"
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_service_fee_eur ;;
  }

  dimension: order_effective_weather_surcharge_eur {
    description: "An extra charge for weather compensations in euros and major currency. If the order
      is not delivered (cancelled), the user might get charged this fee"
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_effective_weather_surcharge_eur ;;
  }

  dimension: order_weather_surcharge_eur {
    description: "An extra charge for weather compensations in euros and major currency. This is the fee that
      will get charged if the order is delivered"
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_weather_surcharge_eur ;;
  }

  dimension: order_effective_min_basket_surcharge_eur {
    description: "A fee charged if the customer did not meet the store minimum basket price, in euros and
      major currencyd"
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_effective_min_basket_surcharge_eur ;;
  }

  dimension: order_initial_delivery_fee_eur {
    description: "Initial amount of delivery fee, before any discounts applied in euros and major currency"
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_initial_delivery_fee_eur ;;
  }

  dimension: order_tax_rate {
    description: "Tax rate applied to an order from 0 to 1.0. As this can be
      changed using Admin panel, there are cases where you will find tax rate 0 for some orders
      (for new cities for example). In any case, it's better to use tax rate per order as global
      country ones could be wrong in some cases (such as Canary Islands 4% VS Spain's 21%) and
      in any case this is the tax that we applied to the order in the end."
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_tax_rate ;;
  }

  dimension: store_name {
    description: "Identifier for the store name associated with an order."
    type: string
    sql: TRIM(${TABLE}.store_name) ;;
  }

  dimension: order_is_first_created_order {
    description: "Identifier to see if the order is the first one of the customer"
    type: yesno
    sql: ${TABLE}.order_is_first_created_order ;;
  }

  dimension: order_is_first_delivered_order {
    description: "Identifier to see if the order is the first delivered to the customer"
    type: yesno
    sql: ${TABLE}.order_is_first_delivered_order ;;
  }

  dimension: order_city_code {
    description: "3-letter city code (IATA-3) indicating the city where the order was executed."
    type: string
    sql: ${TABLE}.order_city_code ;;
  }

  dimension: order_country_code {
    description: "2-letter code (ISO 3166-1 alpha-2) indicating the country where the
      order took place."
    type: string
    sql: ${TABLE}.order_country_code ;;
  }

  dimension: order_country_region {
    description: "Name of the region where the order_country_code belongs. Taken from
      user_defined_geography_data spreadsheet"
    type: string
    sql: ${TABLE}.order_country_region ;;
  }

  dimension: order_country_subregion {
    description: "Name of the subregion where the order_country_code belongs. Taken from
      user_defined_geography_data spreadsheet"
    type: string
    sql: ${TABLE}.order_country_subregion ;;
  }

  dimension: order_currency {
    description: "3-letter code for the currency that was used to pay the order, such as EUR."
    type: string
    sql: ${TABLE}.order_currency ;;
  }

  dimension: order_currency_digits {
    description: "Number of decimal points that the major currency has. E.g. In ES, 1 euro (major) in minor
      currency would be 100 cents, then currency_digits will be 2. Some currencies have no cents, so
      currency_digits in those cases will be 0.
      Dividing the minor amount by 10^currency_digits can effectively get the major amount in all cases."
    type: number
    sql: ${TABLE}.order_currency_digits ;;
  }

  dimension: order_exchange_rate_to_eur {
    description: "Exchange rate for the order, it will be 1 for EUR. The date where the exchange rate
      is taken is the termination time (delivery time if the order was delivered, cancel time if the
      order is canceled).
      Multiplying the local amount by order_exchange_rate_to_eur will convert local to EUR."
    type: number
    sql: ${TABLE}.order_exchange_rate_to_eur ;;
  }

  dimension: order_global_region {
    description: "Global region for the order, based on the country code. Taken from
      user_defined_geography_data spreadsheet"
    type: string
    sql: ${TABLE}.order_global_region ;;
  }

  dimension: order_global_subregion {
    description: "Global subregion for the order, based on the country code. Taken from
      user_defined_geography_data spreadsheet"
    type: string
    sql: ${TABLE}.order_global_subregion ;;
  }

  dimension: order_time_zone {
    description: "Timezone for the order as string (E.g. ‘Europe/Madrid’)"
    type: string
    sql: ${TABLE}.order_time_zone ;;
  }

  dimension: order_timezone {
    description: "No description added"
    type: string
    sql: ${TABLE}.order_timezone ;;
  }

  dimension: order_gtv_with_discounts_eur {
    description: "Order GTV (gross transacted value) with discounts applied, in euros and major format.
      This field takes into account discounts applied to the order, that is, displays the amount actually
      paid by the customer rather than the total amount without any discount.
      This field comes as is from order_pricings."
    type: number
    value_format_name: eur
    sql: ${TABLE}.order_transacted_value_eur ;;
  }

  dimension: order_customer_device_operating_system {
    description: "Operating system of the device that placed the order."
    type: string
    sql: ${TABLE}.order_customer_device_operating_system ;;
  }

  dimension: diff_current_to_creation_week {
    description: "Difference in weeks to current week to creation date"
    type: number
    sql: date_diff('week',${TABLE}.p_creation_date,current_date) ;;
  }

  dimension: diff_current_to_creation_month {
    description: "Difference in weeks to current month to creation date"
    type: number
    sql: date_diff('month',${TABLE}.p_creation_date,current_date) ;;
  }

  dimension: customer_type {
    description: "Identifier for if first order delivered is true"
    type: number
    sql: case when ${TABLE}.order_is_first_created_order = FALSE
      or ${TABLE}.order_is_first_delivered_order=FALSE then 'RC' else 'NC' end ;;
  }

  dimension: order_partner_commission_pct {
    description: "Partners Commission Value [%]. The commission percentage comes AS IS from
      livedb.orders and does not take into account Marketplace, MCD commission and other cases.
      Please refer to delta.partner_commissions_odp.order_base_commissions for the correct
      percentage and value"
    type: number
    value_format_name: percent_2
    sql: ${TABLE}.order_partner_commission_pct ;;
  }

  dimension_group: order_updated {
    description: "Timestamp (UTC) indicating the moment at which an order’s corresponding entry was last
      updated."
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_updated_at ;;
  }

  dimension_group: order_updated_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_updated_local_at ;;
  }

  dimension_group: delivery_duration {
    label: "Delivered Order Duration"
    type: duration
    description: "Total time from started at to terminated at in minutes"
    intervals: [day,hour,minute,second]
    sql_start: ${order_started_local_raw} ;;
    sql_end: ${order_terminated_local_raw} ;;
  }

  dimension_group: order_created_delivery_duration {
    label: "Order Creation to Delivery Duration"
    type: duration
    description: "Total time from order created at to terminated at in minutes"
    intervals: [day,hour,minute,second]
    sql_start: ${order_created_local_raw} ;;
    sql_end: ${order_terminated_local_raw} ;;
  }

  dimension_group: order_accepted_by_partner {
    description: "Timestamp (UTC) indicating the moment at which an order was accepted by the Partner, if any"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_accepted_by_partner_at ;;
  }

  dimension_group: order_accepted_by_partner_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_accepted_by_partner_local_at ;;
  }

  dimension_group: order_activated {
    description: "Timestamp (UTC) indicating the moment at which the order was activated."
    type: time
    timeframes: [
      raw,
      minute,
      time,
      hour_of_day,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_activated_at ;;
  }

  dimension_group: order_activated_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      hour_of_day,
      date,
      day_of_week,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_activated_local_at ;;
  }

  dimension_group: order_courier_arrival_to_delivery {
    description: "Timestamp (UTC) indicating the moment at which the courier arrived at the delivery
      location (if multiple locations, uses the first one)"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_courier_arrival_to_delivery_at ;;
  }

  dimension_group: order_courier_arrival_to_delivery_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_courier_arrival_to_delivery_local_at ;;
  }

  dimension_group: order_courier_arrival_to_pickup {
    description: "Timestamp (UTC) indicating the moment at which the courier arrived to the pickup
      location (if multiple locations, uses the first one). The pickup location is considered as
      the 100m radius around the store. This event is not used to compute the WTP. WTP is calculated
      using the 10m radius"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_courier_arrival_to_pickup_at ;;
  }

  dimension_group: order_courier_arrival_to_pickup_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_courier_arrival_to_pickup_local_at ;;
  }

  dimension_group: order_created {
    description: "Timestamp (UTC) indicating the moment at which the order was created."
    type: time
    timeframes: [
      raw,
      minute,
      time,
      hour_of_day,
      date,
      day_of_week,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_created_at ;;
  }

  dimension_group: order_created_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      hour_of_day,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_created_local_at ;;
  }

  dimension_group: order_dispatched {
    description: "Timestamp (UTC) indicating the moment at which an order was dispatched to the partner
      (the moment the order was received by the partner), if any"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_dispatched_at ;;
  }

  dimension_group: order_dispatched_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_dispatched_local_at ;;
  }

  dimension_group: order_picked_up_by_courier {
    description: "Timestamp (UTC) indicating the moment at which an order was picked up by the
      courier (always null for orders picked up by the customer)"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_picked_up_by_courier_at ;;
  }

  dimension_group: order_picked_up_by_courier_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_picked_up_by_courier_local_at ;;
  }

  dimension_group: order_scheduled {
    description: "Timestamp (UTC) indicating the moment at which an order was scheduled, if any"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_scheduled_at ;;
  }

  dimension_group: order_scheduled_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_scheduled_local_at ;;
  }

  dimension_group: order_started {
    description:
      "Timestamp (UTC) indicating the moment at which an order started from the customer point of view.
      That is, if the order was not scheduled, the order start time from the customer point of view
      is actually the creation time as the customer will start counting the total delivery time from the
      creation time of the order, so we will use that one. If the order was scheduled, then the start time
      for the customer is actually the activation time, so we will use that one."
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_started_at ;;
  }

  dimension_group: order_started_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_started_local_at ;;
  }

  dimension_group: order_terminated {
    description: "Timestamp (UTC) indicating the moment at which an order was terminated, that is if it was
      delivered it will be delivery time, if it was cancelled it will be cancelled time. This field
      replaces order_delivered_at and order_cancelled_at"
    type: time
    timeframes: [
      raw,
      minute,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_terminated_at ;;
  }

  dimension_group: order_terminated_local {
    description: "Conversion of the same field to local time zone for the city"
    type: time
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year,
      week_of_year
    ]
    sql: ${TABLE}.order_terminated_local_at ;;
  }

  dimension: order_is_terminated_in_5min_or_less {
    description: "Flag indicating if the order was terminated (Delivered) or cancelled in 5min or less"
    type: yesno
    sql: DATE_DIFF('second', ${order_created_local_raw}, ${order_terminated_local_raw}) / 60.0 <= 5
        OR (${order_scheduled_local_raw} IS NOT NULL
        AND (${order_activated_local_raw} IS NULL
        OR DATE_DIFF('second', ${order_activated_local_raw}, ${order_terminated_local_raw}) / 60.0 <= 5)) ;;
  }

  dimension_group: partner_dispatch_to_pickup_time {
    label: "Partner Dispatch to Pickup Time (Preparation time)"
    type: duration
    description: "Time between partner dispatch and pickup time"
    intervals: [day,hour,minute,second]
    sql_start: ${order_dispatched_local_raw} ;;
    sql_end: ${order_picked_up_by_courier_local_raw};;
  }

  dimension_group: partner_notified_to_accept {
    label: "Partner Notified -> Accept"
    type: duration
    description: "Time between Notified to Partner and Accepted in minutes"
    intervals: [day,hour,minute,second]
    sql_start: ${order_dispatched_local_raw} ;;
    sql_end: ${order_accepted_by_partner_local_raw};;
  }

  dimension_group: partner_accept_to_pickup {
    label: "Partner Accept -> Pickup"
    type: duration
    description: "Time between Accepted by Partner and Pickup in minutes"
    intervals: [day,hour,minute,second]
    sql_start: ${order_accepted_by_partner_local_raw} ;;
    sql_end: ${order_picked_up_by_courier_local_raw};;
  }

  dimension_group: new_enters_pickup {
    label: "New -> Pickup"
    type: duration
    description: "Time between new order and pickup.The pickup location is considered as the
      100m radius around the store. This event is not used to compute the WTP.
      WTP is calculated using the 10m radius"
    intervals: [day,hour,minute,second]
    sql_start: ${order_started_local_raw} ;;
    sql_end: ${order_courier_arrival_to_pickup_local_raw};;
  }

  dimension_group: waiting_time_pickup {
    label: "Waiting time pickup"
    type: duration
    description: "Time between courier entering PU point and PU time.
      - using the 100m geofence (old/deprecated definition of WTP).
      The curent definition of WTP uses the 10m geofence and is not computed in this view"
    intervals: [day,hour,minute,second]
    sql_start: ${order_courier_arrival_to_pickup_local_raw} ;;
    sql_end: ${order_picked_up_by_courier_local_raw};;
  }

  dimension_group: pickup_to_entering_delivery_zone {
    label: "Pickup -> Entering delivery zone"
    type: duration
    description: "Time between pickup and entering delivery zone"
    intervals: [day,hour,minute,second]
    sql_start: ${order_picked_up_by_courier_local_raw} ;;
    sql_end: ${order_courier_arrival_to_delivery_local_raw} ;;
  }

  dimension_group: pickup_to_delivery_time {
    label: "Pickup -> Delivery time"
    type: duration
    description: "Time between pickup and delivery"
    intervals: [day,hour,minute,second]
    sql_start: ${order_picked_up_by_courier_local_raw} ;;
    sql_end: ${order_terminated_local_raw};;
  }

  measure: count_of_store_address_id {
    description: "Count of Store Address Ids with orders"
    type: count_distinct
    sql: ${TABLE}.store_address_id ;;
  }

  measure: number_of_orders {
    description: "Total orders"
    type: count_distinct
    sql: ${TABLE}.order_id ;;
  }

  measure: count_of_first_orders {
    description: "Total first created orders"
    type: count_distinct
    filters: [order_is_first_created_order: "Yes"]
    sql: ${TABLE}.order_id ;;
  }

  measure: count_of_first_delivered_orders {
    description: "Total first delivered orders"
    type: count_distinct
    filters: [order_is_first_delivered_order: "Yes"]
    sql: ${TABLE}.order_id ;;
  }

  measure: number_of_delivered_orders {
    description: "Total delivered orders"
    type: count_distinct
    filters: [order_final_status: "DeliveredStatus"]
    sql: ${TABLE}.order_id ;;
  }

  measure: number_of_cancelled_orders {
    description: "Total cancelled orders"
    type: count_distinct
    filters: [order_final_status: "CanceledStatus"]
    sql: ${TABLE}.order_id ;;
  }

  measure: number_of_cancelled_orders_due_to_partner {
    description: "Total cancelled orders due to partner, includes these reasons:
      STORE_CLOSED, PRODUCTS_NOT_AVAILABLE, STORE_CAN_NOT_DELIVER,
      PARTNER_PRINTER_ISSUE, TEMPORARY_STORE_CLOSURE,
      PARTNER_NOT_ACCEPTED_ROBOCALL,STORE_NOT_CHECKED_IN"
    type: count_distinct
    filters: {
      field: order_cancel_reason
      value: "STORE_CLOSED,PRODUCTS_NOT_AVAILABLE,STORE_CAN_NOT_DELIVER,
      PARTNER_PRINTER_ISSUE,TEMPORARY_STORE_CLOSURE,
      PARTNER_NOT_ACCEPTED_ROBOCALL,STORE_NOT_CHECKED_IN"
    }
    sql: ${TABLE}.order_id ;;
  }

  measure: number_of_cancelled_orders_due_to_partner_products_not_available {
    type: count_distinct
    description: "Total number of cancellations due to products not available"
    sql: ${TABLE}.order_id ;;
    filters: {
      field: order_cancel_reason
      value: "PRODUCTS_NOT_AVAILABLE"
    }
  }

  measure: sum_total_purchase_eur {
    description: "Sum Total Order Purchase Eur"
    type: sum
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_total_purchase_eur} ;;
  }

  measure: sum_total_purchase_local {
    description: "Sum Total Order Purchase Local"
    # LAMS
    # rule_exemptions: {
    # F1: "2022-12-19 - We need to reference this view to avoid more joins"
    # }
    type: sum
    value_format_name: decimal_2
    html: {{order_currency._value}} {{ rendered_value }};;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_total_purchase_local} ;;
  }

  measure: sum_total_effective_purchase_eur {
    description: "Sum Total Effective Order Purchase Eur"
    type: sum
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_total_effective_purchase_eur} ;;
  }

  measure: sum_total_effective_purchase_local {
    description: "Sum Total Effective Order Purchase Local"
    # LAMS
    # rule_exemptions: {
    # F1: "2022-12-19 - We need to reference this view to avoid more joins"
    # }
    type: sum
    value_format_name: decimal_2
    html: {{order_currency._value}} {{ rendered_value }};;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_total_effective_purchase_local} ;;
  }

  measure: sum_total_estimated_purchase_eur {
    description: "Sum Total Estimated Order Purchase Eur"
    type: sum
    value_format_name: eur
    sql: ${TABLE}.order_estimated_purchase_eur ;;
  }

  measure: sum_total_estimated_purchase_local {
    description: "Sum Total Estimated Order Purchase Local"
    type: sum
    value_format_name: decimal_2
    html: {{order_currency._value}} {{ rendered_value }};;
    sql: ${TABLE}.order_estimated_purchase_local ;;
  }

  measure: sum_order_delivery_fee_eur {
    description: "Sum Total Delivery Fee"
    type: sum_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_delivery_fee_eur} ;;
  }

  measure: sum_order_effective_weather_surcharge_eur {
    description: "Sum Total Order Effective Weather Surcharge"
    type: sum_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_effective_weather_surcharge_eur} ;;
  }

  measure: sum_order_effective_min_basket_surcharge_eur {
    description: "Sum Total Order Effective Min Basket Surcharge"
    type: sum_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_effective_min_basket_surcharge_eur} ;;
  }

  measure: sum_order_initial_delivery_fee_eur {
    description: "Sum Total Order Initial Delivery Fee"
    type: sum_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_initial_delivery_fee_eur} ;;
  }

  measure: sum_order_service_fee_eur {
    description: "Sum Total Order Service Fee"
    type: sum_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_service_fee_eur} ;;
  }

  measure: sum_order_weather_surcharge_eur {
    description: "Sum Total Order Weather Surcharge"
    type: sum_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_weather_surcharge_eur} ;;
  }

  measure: average_total_purchase_eur {
    description: "Average Total Order Purchase"
    type: average_distinct
    value_format_name: eur
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_total_purchase_eur} ;;
  }

  measure: average_total_purchase_local {
    description: "Average Total Order Purchase Local"
    # LAMS
    # rule_exemptions: {
    # F1: "2022-12-19 - We need to reference this view to avoid more joins"
    # }
    type: average_distinct
    value_format_name: decimal_2
    html: {{order_currency._value}} {{ rendered_value }};;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
    sql: ${order_total_purchase_local} ;;
  }

  measure: percentage_of_cancelled_orders {
    description: "Percentage of cancelled orders"
    type: number
    value_format_name: percent_2
    sql: 1.0000 *  ${number_of_cancelled_orders} / nullif(${number_of_orders}, 0);;
  }

  measure: percentage_cancelled_orders_due_to_partner {
    label: "Percentage of cancelled orders due to partner reasons"
    description: "Percentage of total orders cancelled due to partner, includes these reasons: STORE_CLOSED,
      PRODUCTS_NOT_AVAILABLE, STORE_CAN_NOT_DELIVER, PARTNER_PRINTER_ISSUE, TEMPORARY_STORE_CLOSURE,
      PARTNER_NOT_ACCEPTED_ROBOCALL,STORE_NOT_CHECKED_IN"
    type: number
    value_format_name: percent_2
    sql: 1.0000 *  ${number_of_cancelled_orders_due_to_partner} / nullif(${number_of_orders}, 0);;
  }

  measure: number_self_cancellation_less_5_min {
    type: number
    hidden: yes
    # LAMS
    # rule_exemptions: {
    # F1: "2022-02-26 - Need to refer to order_timeliens to caclulate self cx in 5min or less"
    # }
    sql: COUNT(DISTINCT(CASE WHEN
        ${order_final_status} = 'CanceledStatus'
        AND ${order_is_terminated_in_5min_or_less}
        AND (${order_cancel_reason} IS NULL OR ${order_cancel_reason} IN
        ('SELF_CANCELLATION', 'UNKNOWN','OTHER', 'DELIVERY_TAKING_TOO_LONG',
        'COURIER_NOT_ASSIGNED', 'CUSTOMER_DOESNT_WANT_PRODUCTS'))
        THEN ${order_id} ELSE NULL END
        ));;
  }

  measure: hard_cancellation_number {
    label: "Number of Hard Cancellations"
    description: "Number of hard cancellations. It is calculated by subtracting numbe rof self-cancelled
      orders in 5min or less to the total number of cancellations"
    type: number
    sql: ${number_of_cancelled_orders} - ${number_self_cancellation_less_5_min};;
  }

  measure: average_delivery_duration {
    label: "Average Delivered Order Duration"
    description: "Average duration of delivered orders"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_delivery_duration} / 60.00 ;;
  }

  measure: average_order_created_delivery_duration_excl_schedules {
    label: "Average Order Created to Delivery Duration Excluding Scheduled Orders"
    description: "Average duration of delivered orders,
      from creation to delivery. Excludes scheduled orders"
    type: average
    value_format_name: decimal_2
    filters: [order_scheduled_local_date: "NULL"]
    sql: ${seconds_order_created_delivery_duration} / 60.00 ;;
  }

  measure: average_order_created_delivery_duration {
    label: "Average Order Created to Delivery Duration"
    description: "Average duration of delivered orders, from creation to delivery"
    type: average
    value_format_name: decimal_2
    sql: ${seconds_delivery_duration} / 60.00 ;;
  }

  measure: avg_partner_dispatch_pickup {
    label: "Average Partner Dispatch to Pickup Time (Preparation time)"
    description: "Average time between partner dispatch and pickup time"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_partner_dispatch_to_pickup_time} / 60.00 ;;
  }

  measure: avg_partner_notified_to_accept {
    label: "Average Partner Notified -> Acceptance time"
    description: "Time between partner being notified and accepting the order"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_partner_notified_to_accept} / 60.00 ;;
  }

  measure: number_of_orders_with_partner_dispatch_to_pickup_time_below_20min {
    type: count_distinct
    description: "Num. of orders with partner dispatch to pickup time below 20 minutes"
    sql: CASE WHEN ${minutes_partner_dispatch_to_pickup_time} < 20 THEN ${pk1_order_id} ELSE NULL END ;;
  }

  measure: average_partner_accept_to_pickup_time {
    label: "Average Partner Accept -> Pickup time"
    description: "Time between Accepted By Partner and Pickup in minutes"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_partner_accept_to_pickup} / 60.00 ;;
  }

  measure: average_waiting_time_pickup {
    label: "Average Waiting time pickup (min) "
    description: "Time between courier entering PU point and PU time (min)
      - using the 100m geofence (old/deprecated definition of WTP).
      The current definition of WTP uses the 10m geofence and is not computed in this view"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_waiting_time_pickup} / 60.00 ;;
  }

  measure: orders_with_courier_waiting_time_below_5 {
    type: count_distinct
    description: "Num. of orders with courier waiting time below 5 minutes"
    sql: CASE WHEN ${seconds_waiting_time_pickup} <= (5 * 60.00) THEN ${order_id} END ;;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
  }

  measure: percentage_of_orders_with_courier_waiting_time_below_5 {
    type: number
    description: "Percentage of orders with courier waiting time below 5 minutes"
    value_format_name: percent_1
    sql: 1.000 * ${orders_with_courier_waiting_time_below_5} / nullif(${number_of_delivered_orders}, 0) ;;
  }

  measure: average_new_enters_pickup {
    label: "Average New -> Pickup (min)"
    description: "Average time between new order and pickup"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_new_enters_pickup} / 60.00 ;;
  }

  measure: average_pickup_to_delivery_time {
    label: "Average Pickup -> Delivery time (min)"
    description: "Time between pickup and delivery"
    type: average_distinct
    value_format_name: decimal_2
    sql: ${seconds_pickup_to_delivery_time} / 60.00 ;;
  }

  measure: sum_order_gtv_with_discounts_eur {
    description: "Sum Total GTV with discounts applied"
    type: sum_distinct
    value_format_name: eur
    sql: ${order_gtv_with_discounts_eur} ;;
  }
  # order_descriptors_v2 partition key

  measure: partners_commission_eur {
    description: "Partners Commission Value [EUR]. The commission percentage comes AS IS from
      livedb.orders and does not take into account Marketplace, MCD commission and other cases.
      Please refer to delta.partner_commissions_odp.order_base_commissions for the correct
      percentage and value in euros"
    type: sum
    sql: ${TABLE}.order_partner_commission_pct
      * ${TABLE}.order_total_purchase_eur ;;
    value_format_name: eur
  }

  measure: partners_tax_commission_eur {
    description: "Partners Commission Tax Value [EUR]. The commission percentage comes AS IS from
      livedb.orders and does not take into account Marketplace, MCD commission and other cases.
      Please refer to delta.partner_commissions_odp.order_base_commissions for the correct
      percentage and value in euros"
    type: sum
    sql: ${TABLE}.order_tax_rate
      * ${TABLE}.order_partner_commission_pct
      * ${TABLE}.order_total_purchase_eur ;;
    value_format_name: eur
  }

  measure: partners_revenue_eur {
    description: "Partners Revenue [EUR]. The commission percentage comes AS IS from
      livedb.orders and does not take into account Marketplace, MCD commission and other cases.
      Please refer to delta.partner_commissions_odp.order_base_commissions for the correct
      percentage and value in euros"
    type: sum
    sql: ${TABLE}.order_total_purchase_eur
      - ((${TABLE}.order_partner_commission_pct * ${TABLE}.order_total_purchase_eur
        ) * (1 + ${TABLE}.order_tax_rate)) ;;
    value_format_name: eur
  }

  measure: number_of_customers_with_orders {
    description: "Number of all unique customers with delivered order."
    type: count_distinct
    filters: [order_final_status: "DeliveredStatus"]
    sql: ${customer_id} ;;
  }

  measure: number_of_new_customers_with_orders {
    description: "Number of new customers with first order delivered"
    type: count_distinct
    filters: [order_is_first_delivered_order: "Yes"]
    sql: ${customer_id} ;;
  }

  measure: number_of_recurrent_customers_with_orders {
    description: "Number of recurrent customers (that repeated the order)"
    type: number
    sql: ${number_of_customers_with_orders} - ${number_of_new_customers_with_orders};;
  }

  measure: ratio_of_new_customers_to_recurrent_customers {
    description: "Ratio of new customers to the recurrent customers."
    type: number
    value_format_name: decimal_2
    sql: ${number_of_new_customers_with_orders} / nullif(${number_of_recurrent_customers_with_orders}, 0) ;;
  }

  measure: percentage_of_new_customers {
    description: "Percentage of new customers out of all customers with order made."
    type: number
    value_format_name: percent_1
    sql: ${number_of_new_customers_with_orders} / nullif(${number_of_customers_with_orders}, 0);;
  }

  measure: delivery_time_below_20 {
    type: count_distinct
    description: "Num. of orders with delivery duration below 20 minutes"
    sql: CASE WHEN ${seconds_delivery_duration} / 60.00 < 20 THEN ${order_id} ELSE NULL END ;;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
  }

  measure: delivery_time_below_30 {
    type: count_distinct
    description: "Num. of orders with delivery duration below 30 minutes"
    sql: CASE WHEN ${seconds_delivery_duration} / 60.00 < 30 THEN ${order_id} ELSE NULL END ;;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
  }

  measure: delivery_time_below_45 {
    type: count_distinct
    description: "Num. of orders with delivery duration below 45 minutes"
    sql: CASE WHEN ${seconds_delivery_duration} / 60.00 < 45 THEN ${order_id} ELSE NULL END ;;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
  }

  measure: delivery_time_below_60 {
    type: count_distinct
    description: "Num. of orders with delivery duration below 60 minutes"
    sql: CASE WHEN ${seconds_delivery_duration} / 60.00 < 60 THEN ${order_id} ELSE NULL END ;;
    filters: {
      field: order_final_status
      value: "DeliveredStatus"
    }
  }

  measure: percentage_of_delivery_time_below_20 {
    type: number
    description: "Percentage of orders with delivery duration below 20 minutes"
    value_format_name: percent_1
    sql: 1.000 * ${delivery_time_below_20} / nullif(${number_of_delivered_orders}, 0) ;;
  }

  measure: percentage_of_delivery_time_below_30 {
    type: number
    description: "Percentage of orders with delivery duration below 30 minutes"
    value_format_name: percent_1
    sql: 1.000 * ${delivery_time_below_30} / nullif(${number_of_delivered_orders}, 0) ;;
  }

  measure: percentage_of_delivery_time_below_45 {
    type: number
    description: "Percentage of orders with delivery duration below 45 minutes"
    value_format_name: percent_1
    sql: 1.000 *  ${delivery_time_below_45} / nullif(${number_of_delivered_orders}, 0) ;;
  }

  measure: percentage_of_delivery_time_below_60 {
    type: number
    description: "Percentage of orders with delivery duration below 60 minutes"
    value_format_name: percent_1
    sql: 1.000 *  ${delivery_time_below_60} / nullif(${number_of_delivered_orders}, 0) ;;
  }

  measure: average_minutes_pickup_to_entering_delivery_zone {
    type: average
    description: "Average minutes a courier takes to enter the delivery zone after picking up an order"
    label: "Average minutes Pickup -> Entering delivery zone"
    sql: ${minutes_pickup_to_entering_delivery_zone} ;;
  }

  dimension_group: p_creation {
    description: "Partition key for the table from the order_created_at field, in the form of '2022-06-04'"
    type: time
    timeframes: [
      raw,
      time,
      date,
      day_of_week,
      week,
      month,
      quarter,
      year
    ]
    sql: ${TABLE}.p_creation_date ;;
  }
}
